---
title: Kanban
description: A flexible Kanban board component with drag-and-drop columns and items, built on top of dnd-kit.
---

import { PreviewContainer } from "@/components/PreviewContainer";
import { KanbanDemo } from "@/components/lyx/kanban-demo";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { TypeTable } from "fumadocs-ui/components/type-table";
import { Step, Steps } from "fumadocs-ui/components/steps";

## Example

<Tabs items={["Preview", "Code"]}>
  <Tab value="Preview">
    <PreviewContainer>
      <KanbanDemo />
    </PreviewContainer>
  </Tab>
  <Tab value="Code">
    ```js
    "use client";

import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import * as Kanban from "@/components/lyxui/kanban";
import * as React from "react";
import { CircleCheck, Clock, Archive, GripVertical } from "lucide-react";

interface Task {
id: string;
title: string;
priority: "low" | "medium" | "high";
description?: string;
assignee?: string;
dueDate?: string;
}

interface ColumnData {
icon?: React.ReactNode;
data: Task[];
}

const COLUMN_TITLES: Record<string, string> = {
backlog: "Backlog",
inProgress: "In Progress",
done: "Done",
};

export function KanbanDemo() {
  const [columnOrder, setColumnOrder] = React.useState<string[]>([
    "backlog",
    "inProgress",
    "done",
  ]);

const [columns, setColumns] = React.useState<Record<string, ColumnData>>({
backlog: {
icon: <Archive className="h-4 w-4 text-gray-500" />,
data: [
{
id: "11",
title: "Setup CI/CD pipeline",
priority: "high",
assignee: "Mia Chen",
dueDate: "2024-07-10",
},
{
id: "12",
title: "Research analytics tools",
priority: "medium",
assignee: "Liam Patel",
dueDate: "2024-07-15",
},
{
id: "13",
title: "Plan Q3 roadmap",
priority: "low",
assignee: "Olivia Green",
dueDate: "2024-07-20",
},
],
},
inProgress: {
icon: <Clock className="h-4 w-4 text-blue-500" />,
data: [
{
id: "14",
title: "Refactor user profile page",
priority: "high",
assignee: "Noah Kim",
dueDate: "2024-07-08",
},
{
id: "15",
title: "Integrate payment gateway",
priority: "medium",
assignee: "Sophia Lee",
dueDate: "2024-07-12",
},
],
},

    done: {
      icon: <CircleCheck className="h-4 w-4 text-green-500" />,
      data: [
        {
          id: "16",
          title: "Deploy staging environment",
          priority: "high",
          assignee: "Lucas Brown",
          dueDate: "2024-07-01",
        },
        {
          id: "17",
          title: "Fix login bug",
          priority: "low",
          assignee: "Emma Davis",
          dueDate: "2024-06-28",
        },
      ],
    },

});
const kanbanData = React.useMemo(() => {
const result: Record<string, Task[]> = {};
columnOrder.forEach((key) => {
result[key] = columns[key]?.data ?? [];
});
return result;
}, [columns, columnOrder]);

// Update both column order and tasks when drag-and-drop occurs
const handleValueChange = (newData: Record<string, Task[]>) => {
// Update column order
const newOrder = Object.keys(newData);
setColumnOrder(newOrder);

    // Update tasks in each column
    setColumns((prev) => {
      const updated: Record<string, ColumnData> = {};
      newOrder.forEach((key) => {
        updated[key] = {
          ...prev[key],
          data: newData[key] ?? [],
        };
      });
      return updated;
    });

};

return (

<Kanban.Root
value={kanbanData}
onValueChange={handleValueChange}
getItemValue={(item) => item.id} >
<Kanban.Board className="grid auto-rows-fr sm:grid-cols-3 mt-8">
{Object.entries(columns).map(([columnValue, { icon, data }]) => (
<TaskColumn
            key={columnValue}
            value={columnValue}
            tasks={data}
            icon={icon}
          />
))}
</Kanban.Board>
<Kanban.Overlay>
{({ value, variant }) => {
if (variant === "column") {
const columnData = columns[value];
if (!columnData) return null;

            return (
              <TaskColumn
                value={value}
                tasks={columnData.data}
                icon={columnData.icon}
              />
            );
          }

          const task = Object.values(columns)
            .flatMap((col) => col.data)
            .find((task) => task.id === value);

          if (!task) return null;

          return <TaskCard task={task} />;
        }}
      </Kanban.Overlay>
    </Kanban.Root>

);
}

interface TaskCardProps
extends Omit<React.ComponentProps<typeof Kanban.Item>, "value"> {
task: Task;
}

function TaskCard({ task, ...props }: TaskCardProps) {
return (

<Kanban.Item key={task.id} value={task.id} asChild {...props}>
  <div className="rounded-md border bg-card p-2 shadow-xs">
    <div className="flex flex-col gap-2">
      <div className="flex items-center justify-between gap-2">
        <span className="line-clamp-1 font-medium text-sm">{task.title}</span>
        <Badge
          variant={
            task.priority === "high"
              ? "destructive"
              : task.priority === "medium"
              ? "default"
              : "secondary"
          }
          className="pointer-events-none h-5 rounded-sm px-1.5 text-[11px] capitalize"
        >
          {task.priority}
        </Badge>
      </div>
      <div className="flex items-center justify-between text-muted-foreground text-xs">
        {task.assignee && (
          <div className="flex items-center gap-1">
            <div className="size-2 rounded-full bg-primary/20" />
            <span className="line-clamp-1">{task.assignee}</span>
          </div>
        )}
        {task.dueDate && (
          <time className="text-[10px] tabular-nums p-1 bg-background/60 rounded-sm border border-primary/10">
            {task.dueDate}
          </time>
        )}
      </div>
    </div>
  </div>
</Kanban.Item>
); }

interface TaskColumnProps
extends Omit<React.ComponentProps<typeof Kanban.Column>, "children"> {
tasks: Task[];
icon?: React.ReactNode;
}

function TaskColumn({ value, tasks, icon, ...props }: TaskColumnProps) {
return (

<Kanban.Column
  value={value}
  {...props}
  className="bg-card rounded-md p-3 shadow-xs"
>
  <div className="flex items-center justify-between">
    <div className="flex items-center gap-2">
      {icon && <span className="shrink-0">{icon}</span>}
      <span className="font-semibold text-sm">{COLUMN_TITLES[value]}</span>
      <Badge variant="secondary" className="pointer-events-none rounded-sm">
        {tasks.length}
      </Badge>
    </div>
    <Kanban.ColumnHandle asChild>
      <Button variant="ghost" size="icon">
        <GripVertical className="h-4 w-4" />
      </Button>
    </Kanban.ColumnHandle>
  </div>
  <div className="flex flex-col gap-2 p-0.5">
    {tasks.map((task) => (
      <TaskCard key={task.id} task={task} asHandle />
    ))}
  </div>
</Kanban.Column>
); }

    ```

  </Tab>
</Tabs>

## Installation

### CLI `(Recommended)`

<Tabs items={["npm", "yarn", "pnpm", "bun"]}>
  <Tab value="npm">

```bash
npx shadcn@latest add http://lyxui.wisplabs.xyz/r/kanban.json
```

  </Tab>
  <Tab value="yarn">

```bash
yarn shadcn@latest add http://lyxui.wisplabs.xyz/r/kanban.json
```

  </Tab>
  <Tab value="pnpm">

```bash
pnpm dlx shadcn@latest add http://lyxui.wisplabs.xyz/r/kanban.json
```

  </Tab>
  <Tab value="bun">

```bash
bunx --bun  add http://lyxui.wisplabs.xyz/r/kanban.json
```

  </Tab>
</Tabs>

### Manual

<Steps>
<Step>
Install the following dependencies:
<Tabs items={["npm", "yarn", "pnpm", "bun"]}>
  <Tab value="npm">
  
```bash
npm install @dnd-kit/modifiers @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities @radix-ui/react-slot
```
  
  </Tab>
  <Tab value="yarn">

```bash
yarn add @dnd-kit/modifiers @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities @radix-ui/react-slot
```

  </Tab>
  <Tab value="pnpm">
  ```bash
pnpm i @dnd-kit/modifiers @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities @radix-ui/react-slot
  ```
  
  </Tab>
  <Tab value="bun">
  ```bash
bun add @dnd-kit/modifiers @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities @radix-ui/react-slot
  ```
  
  </Tab>
</Tabs>
</Step>
<Step>
Copy the source code to `components/lyxui/kanban.tsx`
```js
"use client";

import {
  type Announcements,
  type CollisionDetection,
  DndContext,
  type DndContextProps,
  type DragCancelEvent,
  type DragEndEvent,
  type DragOverEvent,
  DragOverlay,
  type DragStartEvent,
  type DraggableAttributes,
  type DraggableSyntheticListeners,
  type DropAnimation,
  type DroppableContainer,
  KeyboardCode,
  type KeyboardCoordinateGetter,
  KeyboardSensor,
  MeasuringStrategy,
  MouseSensor,
  TouchSensor,
  type UniqueIdentifier,
  closestCenter,
  closestCorners,
  defaultDropAnimationSideEffects,
  getFirstCollision,
  pointerWithin,
  rectIntersection,
  useSensor,
  useSensors,
} from "@dnd-kit/core";
import {
  type AnimateLayoutChanges,
  SortableContext,
  type SortableContextProps,
  arrayMove,
  defaultAnimateLayoutChanges,
  horizontalListSortingStrategy,
  useSortable,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { Slot } from "@radix-ui/react-slot";
import * as React from "react";
import * as ReactDOM from "react-dom";

import { useComposedRefs } from "@/lib/compose-refs";
import { cn } from "@/lib/utils";

const directions: string[] = [
KeyboardCode.Down,
KeyboardCode.Right,
KeyboardCode.Up,
KeyboardCode.Left,
];

const coordinateGetter: KeyboardCoordinateGetter = (event, { context }) => {
const { active, droppableRects, droppableContainers, collisionRect } =
context;

if (directions.includes(event.code)) {
event.preventDefault();

    if (!active || !collisionRect) return;

    const filteredContainers: DroppableContainer[] = [];

    for (const entry of droppableContainers.getEnabled()) {
      if (!entry || entry?.disabled) return;

      const rect = droppableRects.get(entry.id);

      if (!rect) return;

      const data = entry.data.current;

      if (data) {
        const { type, children } = data;

        if (type === "container" && children?.length > 0) {
          if (active.data.current?.type !== "container") {
            return;
          }
        }
      }

      switch (event.code) {
        case KeyboardCode.Down:
          if (collisionRect.top < rect.top) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Up:
          if (collisionRect.top > rect.top) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Left:
          if (collisionRect.left >= rect.left + rect.width) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Right:
          if (collisionRect.left + collisionRect.width <= rect.left) {
            filteredContainers.push(entry);
          }
          break;
      }
    }

    const collisions = closestCorners({
      active,
      collisionRect: collisionRect,
      droppableRects,
      droppableContainers: filteredContainers,
      pointerCoordinates: null,
    });
    const closestId = getFirstCollision(collisions, "id");

    if (closestId != null) {
      const newDroppable = droppableContainers.get(closestId);
      const newNode = newDroppable?.node.current;
      const newRect = newDroppable?.rect.current;

      if (newNode && newRect) {
        if (newDroppable.id === "placeholder") {
          return {
            x: newRect.left + (newRect.width - collisionRect.width) / 2,
            y: newRect.top + (newRect.height - collisionRect.height) / 2,
          };
        }

        if (newDroppable.data.current?.type === "container") {
          return {
            x: newRect.left + 20,
            y: newRect.top + 74,
          };
        }

        return {
          x: newRect.left,
          y: newRect.top,
        };
      }
    }

}

return undefined;
};

const ROOT_NAME = "Kanban";
const BOARD_NAME = "KanbanBoard";
const COLUMN_NAME = "KanbanColumn";
const COLUMN_HANDLE_NAME = "KanbanColumnHandle";
const ITEM_NAME = "KanbanItem";
const ITEM_HANDLE_NAME = "KanbanItemHandle";
const OVERLAY_NAME = "KanbanOverlay";

interface KanbanContextValue<T> {
id: string;
items: Record<UniqueIdentifier, T[]>;
modifiers: DndContextProps["modifiers"];
strategy: SortableContextProps["strategy"];
orientation: "horizontal" | "vertical";
activeId: UniqueIdentifier | null;
setActiveId: (id: UniqueIdentifier | null) => void;
getItemValue: (item: T) => UniqueIdentifier;
flatCursor: boolean;
}

const KanbanContext = React.createContext<KanbanContextValue<unknown> | null>(
null,
);
KanbanContext.displayName = ROOT_NAME;

function useKanbanContext(consumerName: string) {
const context = React.useContext(KanbanContext);
if (!context) {
throw new Error(`\`${consumerName}\` must be used within \`${ROOT_NAME}\``);
}
return context;
}

interface GetItemValue<T> {
/\*\*

- Callback that returns a unique identifier for each kanban item. Required for array of objects.
- @example getItemValue={(item) => item.id}
  \*/
  getItemValue: (item: T) => UniqueIdentifier;
  }

type KanbanRootProps<T> = Omit<DndContextProps, "collisionDetection"> &
GetItemValue<T> & {
value: Record<UniqueIdentifier, T[]>;
onValueChange?: (columns: Record<UniqueIdentifier, T[]>) => void;
onMove?: (
event: DragEndEvent & { activeIndex: number; overIndex: number },
) => void;
strategy?: SortableContextProps["strategy"];
orientation?: "horizontal" | "vertical";
flatCursor?: boolean;
} & (T extends object ? GetItemValue<T> : Partial<GetItemValue<T>>);

function KanbanRoot<T>(props: KanbanRootProps<T>) {
const {
value,
onValueChange,
modifiers,
strategy = verticalListSortingStrategy,
orientation = "horizontal",
onMove,
getItemValue: getItemValueProp,
accessibility,
flatCursor = false,
...kanbanProps
} = props;

const id = React.useId();
const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);
const lastOverIdRef = React.useRef<UniqueIdentifier | null>(null);
const hasMovedRef = React.useRef(false);
const sensors = useSensors(
useSensor(MouseSensor),
useSensor(TouchSensor),
useSensor(KeyboardSensor, {
coordinateGetter,
}),
);

const getItemValue = React.useCallback(
(item: T): UniqueIdentifier => {
if (typeof item === "object" && !getItemValueProp) {
throw new Error("getItemValue is required when using array of objects");
}
return getItemValueProp
? getItemValueProp(item)
: (item as UniqueIdentifier);
},
[getItemValueProp],
);

const getColumn = React.useCallback(
(id: UniqueIdentifier) => {
if (id in value) return id;

      for (const [columnId, items] of Object.entries(value)) {
        if (items.some((item) => getItemValue(item) === id)) {
          return columnId;
        }
      }

      return null;
    },
    [value, getItemValue],

);

const collisionDetection: CollisionDetection = React.useCallback(
(args) => {
if (activeId && activeId in value) {
return closestCenter({
...args,
droppableContainers: args.droppableContainers.filter(
(container) => container.id in value,
),
});
}

      const pointerIntersections = pointerWithin(args);
      const intersections =
        pointerIntersections.length > 0
          ? pointerIntersections
          : rectIntersection(args);
      let overId = getFirstCollision(intersections, "id");

      if (!overId) {
        if (hasMovedRef.current) {
          lastOverIdRef.current = activeId;
        }
        return lastOverIdRef.current ? [{ id: lastOverIdRef.current }] : [];
      }

      if (overId in value) {
        const containerItems = value[overId];
        if (containerItems && containerItems.length > 0) {
          const closestItem = closestCenter({
            ...args,
            droppableContainers: args.droppableContainers.filter(
              (container) =>
                container.id !== overId &&
                containerItems.some(
                  (item) => getItemValue(item) === container.id,
                ),
            ),
          });

          if (closestItem.length > 0) {
            overId = closestItem[0]?.id ?? overId;
          }
        }
      }

      lastOverIdRef.current = overId;
      return [{ id: overId }];
    },
    [activeId, value, getItemValue],

);

const onDragStart = React.useCallback(
(event: DragStartEvent) => {
kanbanProps.onDragStart?.(event);

      if (event.activatorEvent.defaultPrevented) return;
      setActiveId(event.active.id);
    },
    [kanbanProps.onDragStart],

);

const onDragOver = React.useCallback(
(event: DragOverEvent) => {
kanbanProps.onDragOver?.(event);

      if (event.activatorEvent.defaultPrevented) return;

      const { active, over } = event;
      if (!over) return;

      const activeColumn = getColumn(active.id);
      const overColumn = getColumn(over.id);

      if (!activeColumn || !overColumn) return;

      if (activeColumn === overColumn) {
        const items = value[activeColumn];
        if (!items) return;

        const activeIndex = items.findIndex(
          (item) => getItemValue(item) === active.id,
        );
        const overIndex = items.findIndex(
          (item) => getItemValue(item) === over.id,
        );

        if (activeIndex !== overIndex) {
          const newColumns = { ...value };
          newColumns[activeColumn] = arrayMove(items, activeIndex, overIndex);
          onValueChange?.(newColumns);
        }
      } else {
        const activeItems = value[activeColumn];
        const overItems = value[overColumn];

        if (!activeItems || !overItems) return;

        const activeIndex = activeItems.findIndex(
          (item) => getItemValue(item) === active.id,
        );

        if (activeIndex === -1) return;

        const activeItem = activeItems[activeIndex];
        if (!activeItem) return;

        const updatedItems = {
          ...value,
          [activeColumn]: activeItems.filter(
            (item) => getItemValue(item) !== active.id,
          ),
          [overColumn]: [...overItems, activeItem],
        };

        onValueChange?.(updatedItems);
        hasMovedRef.current = true;
      }
    },
    [value, getColumn, getItemValue, onValueChange, kanbanProps.onDragOver],

);

const onDragEnd = React.useCallback(
(event: DragEndEvent) => {
kanbanProps.onDragEnd?.(event);

      if (event.activatorEvent.defaultPrevented) return;

      const { active, over } = event;

      if (!over) {
        setActiveId(null);
        return;
      }

      if (active.id in value && over.id in value) {
        const activeIndex = Object.keys(value).indexOf(active.id as string);
        const overIndex = Object.keys(value).indexOf(over.id as string);

        if (activeIndex !== overIndex) {
          const orderedColumns = Object.keys(value);
          const newOrder = arrayMove(orderedColumns, activeIndex, overIndex);

          const newColumns: Record<UniqueIdentifier, T[]> = {};
          for (const key of newOrder) {
            const items = value[key];
            if (items) {
              newColumns[key] = items;
            }
          }

          if (onMove) {
            onMove({ ...event, activeIndex, overIndex });
          } else {
            onValueChange?.(newColumns);
          }
        }
      } else {
        const activeColumn = getColumn(active.id);
        const overColumn = getColumn(over.id);

        if (!activeColumn || !overColumn) {
          setActiveId(null);
          return;
        }

        if (activeColumn === overColumn) {
          const items = value[activeColumn];
          if (!items) {
            setActiveId(null);
            return;
          }

          const activeIndex = items.findIndex(
            (item) => getItemValue(item) === active.id,
          );
          const overIndex = items.findIndex(
            (item) => getItemValue(item) === over.id,
          );

          if (activeIndex !== overIndex) {
            const newColumns = { ...value };
            newColumns[activeColumn] = arrayMove(items, activeIndex, overIndex);
            if (onMove) {
              onMove({
                ...event,
                activeIndex,
                overIndex,
              });
            } else {
              onValueChange?.(newColumns);
            }
          }
        }
      }

      setActiveId(null);
      hasMovedRef.current = false;
    },
    [
      value,
      getColumn,
      getItemValue,
      onValueChange,
      onMove,
      kanbanProps.onDragEnd,
    ],

);

const onDragCancel = React.useCallback(
(event: DragCancelEvent) => {
kanbanProps.onDragCancel?.(event);

      if (event.activatorEvent.defaultPrevented) return;

      setActiveId(null);
      hasMovedRef.current = false;
    },
    [kanbanProps.onDragCancel],

);

const announcements: Announcements = React.useMemo(
() => ({
onDragStart({ active }) {
const isColumn = active.id in value;
const itemType = isColumn ? "column" : "item";
const position = isColumn
? Object.keys(value).indexOf(active.id as string) + 1
: (() => {
const column = getColumn(active.id);
if (!column || !value[column]) return 1;
return (
value[column].findIndex(
(item) => getItemValue(item) === active.id,
) + 1
);
})();
const total = isColumn
? Object.keys(value).length
: (() => {
const column = getColumn(active.id);
return column ? (value[column]?.length ?? 0) : 0;
})();

        return `Picked up ${itemType} at position ${position} of ${total}`;
      },
      onDragOver({ active, over }) {
        if (!over) return;

        const isColumn = active.id in value;
        const itemType = isColumn ? "column" : "item";
        const position = isColumn
          ? Object.keys(value).indexOf(over.id as string) + 1
          : (() => {
              const column = getColumn(over.id);
              if (!column || !value[column]) return 1;
              return (
                value[column].findIndex(
                  (item) => getItemValue(item) === over.id,
                ) + 1
              );
            })();
        const total = isColumn
          ? Object.keys(value).length
          : (() => {
              const column = getColumn(over.id);
              return column ? (value[column]?.length ?? 0) : 0;
            })();

        const overColumn = getColumn(over.id);
        const activeColumn = getColumn(active.id);

        if (isColumn) {
          return `${itemType} is now at position ${position} of ${total}`;
        }

        if (activeColumn !== overColumn) {
          return `${itemType} is now at position ${position} of ${total} in ${overColumn}`;
        }

        return `${itemType} is now at position ${position} of ${total}`;
      },
      onDragEnd({ active, over }) {
        if (!over) return;

        const isColumn = active.id in value;
        const itemType = isColumn ? "column" : "item";
        const position = isColumn
          ? Object.keys(value).indexOf(over.id as string) + 1
          : (() => {
              const column = getColumn(over.id);
              if (!column || !value[column]) return 1;
              return (
                value[column].findIndex(
                  (item) => getItemValue(item) === over.id,
                ) + 1
              );
            })();
        const total = isColumn
          ? Object.keys(value).length
          : (() => {
              const column = getColumn(over.id);
              return column ? (value[column]?.length ?? 0) : 0;
            })();

        const overColumn = getColumn(over.id);
        const activeColumn = getColumn(active.id);

        if (isColumn) {
          return `${itemType} was dropped at position ${position} of ${total}`;
        }

        if (activeColumn !== overColumn) {
          return `${itemType} was dropped at position ${position} of ${total} in ${overColumn}`;
        }

        return `${itemType} was dropped at position ${position} of ${total}`;
      },
      onDragCancel({ active }) {
        const isColumn = active.id in value;
        const itemType = isColumn ? "column" : "item";
        return `Dragging was cancelled. ${itemType} was dropped.`;
      },
    }),
    [value, getColumn, getItemValue],

);

const contextValue = React.useMemo<KanbanContextValue<T>>(
() => ({
id,
items: value,
modifiers,
strategy,
orientation,
activeId,
setActiveId,
getItemValue,
flatCursor,
}),
[
id,
value,
activeId,
modifiers,
strategy,
orientation,
getItemValue,
flatCursor,
],
);

return (

<KanbanContext.Provider value={contextValue as KanbanContextValue<unknown>}>
<DndContext
collisionDetection={collisionDetection}
modifiers={modifiers}
sensors={sensors}
{...kanbanProps}
id={id}
measuring={{
          droppable: {
            strategy: MeasuringStrategy.Always,
          },
        }}
onDragStart={onDragStart}
onDragOver={onDragOver}
onDragEnd={onDragEnd}
onDragCancel={onDragCancel}
accessibility={{
          announcements,
          screenReaderInstructions: {
            draggable: `
            To pick up a kanban item or column, press space or enter.
            While dragging, use the arrow keys to move the item.
            Press space or enter again to drop the item in its new position, or press escape to cancel.
          `,
          },
          ...accessibility,
        }}
/>
</KanbanContext.Provider>
);
}

const KanbanBoardContext = React.createContext<boolean>(false);
KanbanBoardContext.displayName = BOARD_NAME;

interface KanbanBoardProps extends React.ComponentPropsWithoutRef<"div"> {
children: React.ReactNode;
asChild?: boolean;
}

const KanbanBoard = React.forwardRef<HTMLDivElement, KanbanBoardProps>(
(props, forwardedRef) => {
const { asChild, className, ...boardProps } = props;

    const context = useKanbanContext(BOARD_NAME);

    const columns = React.useMemo(() => {
      return Object.keys(context.items);
    }, [context.items]);

    const BoardPrimitive = asChild ? Slot : "div";

    return (
      <KanbanBoardContext.Provider value={true}>
        <SortableContext
          items={columns}
          strategy={
            context.orientation === "horizontal"
              ? horizontalListSortingStrategy
              : verticalListSortingStrategy
          }
        >
          <BoardPrimitive
            aria-orientation={context.orientation}
            data-orientation={context.orientation}
            data-slot="kanban-board"
            {...boardProps}
            ref={forwardedRef}
            className={cn(
              "flex size-full gap-4",
              context.orientation === "horizontal" ? "flex-row" : "flex-col",
              className,
            )}
          />
        </SortableContext>
      </KanbanBoardContext.Provider>
    );

},
);
KanbanBoard.displayName = BOARD_NAME;

interface KanbanColumnContextValue {
id: string;
attributes: DraggableAttributes;
listeners: DraggableSyntheticListeners | undefined;
setActivatorNodeRef: (node: HTMLElement | null) => void;
isDragging?: boolean;
disabled?: boolean;
}

const KanbanColumnContext =
React.createContext<KanbanColumnContextValue | null>(null);
KanbanColumnContext.displayName = COLUMN_NAME;

function useKanbanColumnContext(consumerName: string) {
const context = React.useContext(KanbanColumnContext);
if (!context) {
throw new Error(
`\`${consumerName}\` must be used within \`${COLUMN_NAME}\``,
);
}
return context;
}

const animateLayoutChanges: AnimateLayoutChanges = (args) =>
defaultAnimateLayoutChanges({ ...args, wasDragging: true });

interface KanbanColumnProps extends React.ComponentPropsWithoutRef<"div"> {
value: UniqueIdentifier;
children: React.ReactNode;
asChild?: boolean;
asHandle?: boolean;
disabled?: boolean;
}

const KanbanColumn = React.forwardRef<HTMLDivElement, KanbanColumnProps>(
(props, forwardedRef) => {
const {
value,
asChild,
asHandle,
disabled,
className,
style,
...columnProps
} = props;

    const id = React.useId();
    const context = useKanbanContext(COLUMN_NAME);
    const inBoard = React.useContext(KanbanBoardContext);
    const inOverlay = React.useContext(KanbanOverlayContext);

    if (!inBoard && !inOverlay) {
      throw new Error(
        `\`${COLUMN_NAME}\` must be used within \`${BOARD_NAME}\` or \`${OVERLAY_NAME}\``,
      );
    }

    if (value === "") {
      throw new Error(`\`${COLUMN_NAME}\` value cannot be an empty string`);
    }

    const {
      attributes,
      listeners,
      setNodeRef,
      setActivatorNodeRef,
      transform,
      transition,
      isDragging,
    } = useSortable({
      id: value,
      disabled,
      animateLayoutChanges,
    });

    const composedRef = useComposedRefs(forwardedRef, (node) => {
      if (disabled) return;
      setNodeRef(node);
    });

    const composedStyle = React.useMemo<React.CSSProperties>(() => {
      return {
        transform: CSS.Transform.toString(transform),
        transition,
        ...style,
      };
    }, [transform, transition, style]);

    const items = React.useMemo(() => {
      const items = context.items[value] ?? [];
      return items.map((item) => context.getItemValue(item));
    }, [context.items, value, context.getItemValue]);

    const columnContext = React.useMemo<KanbanColumnContextValue>(
      () => ({
        id,
        attributes,
        listeners,
        setActivatorNodeRef,
        isDragging,
        disabled,
      }),
      [id, attributes, listeners, setActivatorNodeRef, isDragging, disabled],
    );

    const ColumnPrimitive = asChild ? Slot : "div";

    return (
      <KanbanColumnContext.Provider value={columnContext}>
        <SortableContext
          items={items}
          strategy={
            context.orientation === "horizontal"
              ? horizontalListSortingStrategy
              : verticalListSortingStrategy
          }
        >
          <ColumnPrimitive
            id={id}
            data-disabled={disabled}
            data-dragging={isDragging ? "" : undefined}
            data-slot="kanban-column"
            {...columnProps}
            {...(asHandle && !disabled ? attributes : {})}
            {...(asHandle && !disabled ? listeners : {})}
            ref={composedRef}
            style={composedStyle}
            className={cn(
              "flex size-full flex-col gap-2 rounded-lg border bg-zinc-100 p-2.5 aria-disabled:pointer-events-none aria-disabled:opacity-50 dark:bg-zinc-900",
              {
                "touch-none select-none": asHandle,
                "cursor-default": context.flatCursor,
                "data-dragging:cursor-grabbing": !context.flatCursor,
                "cursor-grab": !isDragging && asHandle && !context.flatCursor,
                "opacity-50": isDragging,
                "pointer-events-none opacity-50": disabled,
              },
              className,
            )}
          />
        </SortableContext>
      </KanbanColumnContext.Provider>
    );

},
);
KanbanColumn.displayName = COLUMN_NAME;

interface KanbanColumnHandleProps
extends React.ComponentPropsWithoutRef<"button"> {
asChild?: boolean;
}

const KanbanColumnHandle = React.forwardRef<
HTMLButtonElement,
KanbanColumnHandleProps

> ((props, forwardedRef) => {
> const { asChild, disabled, className, ...columnHandleProps } = props;

const context = useKanbanContext(COLUMN_NAME);
const columnContext = useKanbanColumnContext(COLUMN_HANDLE_NAME);

const isDisabled = disabled ?? columnContext.disabled;

const composedRef = useComposedRefs(forwardedRef, (node) => {
if (isDisabled) return;
columnContext.setActivatorNodeRef(node);
});

const HandlePrimitive = asChild ? Slot : "button";

return (

<HandlePrimitive
  type="button"
  aria-controls={columnContext.id}
  data-disabled={isDisabled}
  data-dragging={columnContext.isDragging ? "" : undefined}
  data-slot="kanban-column-handle"
  {...columnHandleProps}
  {...(isDisabled ? {} : columnContext.attributes)}
  {...(isDisabled ? {} : columnContext.listeners)}
  ref={composedRef}
  className={cn(
    "select-none disabled:pointer-events-none disabled:opacity-50",
    context.flatCursor
      ? "cursor-default"
      : "cursor-grab data-dragging:cursor-grabbing",
    className
  )}
  disabled={isDisabled}
/>
); }); KanbanColumnHandle.displayName = COLUMN_HANDLE_NAME;

interface KanbanItemContextValue {
id: string;
attributes: DraggableAttributes;
listeners: DraggableSyntheticListeners | undefined;
setActivatorNodeRef: (node: HTMLElement | null) => void;
isDragging?: boolean;
disabled?: boolean;
}

const KanbanItemContext = React.createContext<KanbanItemContextValue | null>(
null,
);
KanbanItemContext.displayName = ITEM_NAME;

function useKanbanItemContext(consumerName: string) {
const context = React.useContext(KanbanItemContext);
if (!context) {
throw new Error(`\`${consumerName}\` must be used within \`${ITEM_NAME}\``);
}
return context;
}

interface KanbanItemProps extends React.ComponentPropsWithoutRef<"div"> {
value: UniqueIdentifier;
asHandle?: boolean;
asChild?: boolean;
disabled?: boolean;
}

const KanbanItem = React.forwardRef<HTMLDivElement, KanbanItemProps>(
(props, forwardedRef) => {
const {
value,
style,
asHandle,
asChild,
disabled,
className,
...itemProps
} = props;

    const id = React.useId();
    const context = useKanbanContext(ITEM_NAME);
    const inBoard = React.useContext(KanbanBoardContext);
    const inOverlay = React.useContext(KanbanOverlayContext);

    if (!inBoard && !inOverlay) {
      throw new Error(`\`${ITEM_NAME}\` must be used within \`${BOARD_NAME}\``);
    }

    const {
      attributes,
      listeners,
      setNodeRef,
      setActivatorNodeRef,
      transform,
      transition,
      isDragging,
    } = useSortable({ id: value, disabled });

    if (value === "") {
      throw new Error(`\`${ITEM_NAME}\` value cannot be an empty string`);
    }

    const composedRef = useComposedRefs(forwardedRef, (node) => {
      if (disabled) return;
      setNodeRef(node);
    });

    const composedStyle = React.useMemo<React.CSSProperties>(() => {
      return {
        transform: CSS.Transform.toString(transform),
        transition,
        ...style,
      };
    }, [transform, transition, style]);

    const itemContext = React.useMemo<KanbanItemContextValue>(
      () => ({
        id,
        attributes,
        listeners,
        setActivatorNodeRef,
        isDragging,
        disabled,
      }),
      [id, attributes, listeners, setActivatorNodeRef, isDragging, disabled],
    );

    const ItemPrimitive = asChild ? Slot : "div";

    return (
      <KanbanItemContext.Provider value={itemContext}>
        <ItemPrimitive
          id={id}
          data-disabled={disabled}
          data-dragging={isDragging ? "" : undefined}
          data-slot="kanban-item"
          {...itemProps}
          {...(asHandle && !disabled ? attributes : {})}
          {...(asHandle && !disabled ? listeners : {})}
          ref={composedRef}
          style={composedStyle}
          className={cn(
            "focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1",
            {
              "touch-none select-none": asHandle,
              "cursor-default": context.flatCursor,
              "data-dragging:cursor-grabbing": !context.flatCursor,
              "cursor-grab": !isDragging && asHandle && !context.flatCursor,
              "opacity-50": isDragging,
              "pointer-events-none opacity-50": disabled,
            },
            className,
          )}
        />
      </KanbanItemContext.Provider>
    );

},
);
KanbanItem.displayName = ITEM_NAME;

interface KanbanItemHandleProps
extends React.ComponentPropsWithoutRef<"button"> {
asChild?: boolean;
}

const KanbanItemHandle = React.forwardRef<
HTMLButtonElement,
KanbanItemHandleProps

> ((props, forwardedRef) => {
> const { asChild, disabled, className, ...itemHandleProps } = props;

const context = useKanbanContext(ITEM_HANDLE_NAME);
const itemContext = useKanbanItemContext(ITEM_HANDLE_NAME);

const isDisabled = disabled ?? itemContext.disabled;

const composedRef = useComposedRefs(forwardedRef, (node) => {
if (isDisabled) return;
itemContext.setActivatorNodeRef(node);
});

const HandlePrimitive = asChild ? Slot : "button";

return (

<HandlePrimitive
  type="button"
  aria-controls={itemContext.id}
  data-disabled={isDisabled}
  data-dragging={itemContext.isDragging ? "" : undefined}
  data-slot="kanban-item-handle"
  {...itemHandleProps}
  {...(isDisabled ? {} : itemContext.attributes)}
  {...(isDisabled ? {} : itemContext.listeners)}
  ref={composedRef}
  className={cn(
    "select-none disabled:pointer-events-none disabled:opacity-50",
    context.flatCursor
      ? "cursor-default"
      : "cursor-grab data-dragging:cursor-grabbing",
    className
  )}
  disabled={isDisabled}
/>
); }); KanbanItemHandle.displayName = ITEM_HANDLE_NAME;

const KanbanOverlayContext = React.createContext(false);
KanbanOverlayContext.displayName = OVERLAY_NAME;

const dropAnimation: DropAnimation = {
sideEffects: defaultDropAnimationSideEffects({
styles: {
active: {
opacity: "0.4",
},
},
}),
};

interface KanbanOverlayProps
extends Omit<React.ComponentPropsWithoutRef<typeof DragOverlay>, "children"> {
container?: Element | DocumentFragment | null;
children?:
| ((params: {
value: UniqueIdentifier;
variant: "column" | "item";
}) => React.ReactNode)
| React.ReactNode;
}

function KanbanOverlay(props: KanbanOverlayProps) {
const { container: containerProp, children, ...overlayProps } = props;

const context = useKanbanContext(OVERLAY_NAME);

const [mounted, setMounted] = React.useState(false);
React.useLayoutEffect(() => setMounted(true), []);

const container =
containerProp ?? (mounted ? globalThis.document?.body : null);

if (!container) return null;

const variant =
context.activeId && context.activeId in context.items ? "column" : "item";

return ReactDOM.createPortal(

<DragOverlay
  dropAnimation={dropAnimation}
  modifiers={context.modifiers}
  className={cn(!context.flatCursor && "cursor-grabbing")}
  {...overlayProps}
>
  <KanbanOverlayContext.Provider value={true}>
    {context.activeId && children
      ? typeof children === "function"
        ? children({
            value: context.activeId,
            variant,
          })
        : children
      : null}
  </KanbanOverlayContext.Provider>
</DragOverlay>
, container, ); }

export {
  KanbanRoot as Kanban,
  KanbanBoard,
  KanbanColumn,
  KanbanColumnHandle,
  KanbanItem,
  KanbanItemHandle,
  KanbanOverlay,
  //
  KanbanRoot as Root,
  KanbanBoard as Board,
  KanbanColumn as Column,
  KanbanColumnHandle as ColumnHandle,
  KanbanItem as Item,
  KanbanItemHandle as ItemHandle,
  KanbanOverlay as Overlay,
};

````
</Step>
<Step>
Copy the library code to `lib/compose-refs.ts`
```js
import * as React from "react";

type PossibleRef<T> = React.Ref<T> | undefined;

/**
 * Set a given ref to a given value
 * This utility takes care of different types of refs: callback refs and RefObject(s)
 */
function setRef<T>(ref: PossibleRef<T>, value: T) {
  if (typeof ref === "function") {
    return ref(value);
  }

  if (ref !== null && ref !== undefined) {
    ref.current = value;
  }
}

/**
 * A utility to compose multiple refs together
 * Accepts callback refs and RefObject(s)
 */
function composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup === "function") {
        hasCleanup = true;
      }
      return cleanup;
    });

    // React <19 will log an error to the console if a callback ref returns a
    // value. We don't use ref cleanups internally so this will only happen if a
    // user's ref callback returns a value, which we only expect if they are
    // using the cleanup functionality added in React 19.
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup === "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}

/**
 * A custom hook that composes multiple refs
 * Accepts callback refs and RefObject(s)
 */
function useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {
  // eslint-disable-next-line react-hooks/exhaustive-deps
  return React.useCallback(composeRefs(...refs), refs);
}

export { composeRefs, useComposedRefs };

````

</Step>
<Step>
You are ready to use the component! Simply import it and start using it in your code.
</Step>
</Steps>

## Props

### Kanban.Root

<TypeTable
  type={{
    value: {
      description:
        "The kanban data. An object where each key is a column id and the value is an array of items.",
      type: "Record<string, T[]>",
      default: "required",
    },
    onValueChange: {
      description:
        "Callback when the kanban data changes (e.g. after drag-and-drop).",
      type: "(columns: Record<string, T[]>) => void",
      default: "undefined",
    },
    getItemValue: {
      description:
        "Function to get a unique identifier from an item. Required for array of objects.",
      type: "(item: T) => string | number",
      default: "required for objects",
    },
    strategy: {
      description: "Sorting strategy for columns/items.",
      type: "SortableContextProps['strategy']",
      default: "verticalListSortingStrategy",
    },
    orientation: {
      description: "Layout orientation.",
      type: '"horizontal" | "vertical"',
      default: '"horizontal"',
    },
    flatCursor: {
      description: "If true, disables the grab cursor.",
      type: "boolean",
      default: "false",
    },
  }}
/>

### Kanban.Column

<TypeTable
  type={{
    value: {
      description: "The column id.",
      type: "string",
      default: "required",
    },
    children: {
      description: "Column content (usually Kanban.Item components).",
      type: "React.ReactNode",
      default: "required",
    },
    asHandle: {
      description: "If true, makes the column draggable by the whole column.",
      type: "boolean",
      default: "false",
    },
    disabled: {
      description: "Disables drag-and-drop for this column.",
      type: "boolean",
      default: "false",
    },
  }}
/>

### Kanban.Item

<TypeTable
  type={{
    value: {
      description: "The item id.",
      type: "string",
      default: "required",
    },
    asHandle: {
      description: "If true, makes the item draggable by the whole item.",
      type: "boolean",
      default: "false",
    },
    disabled: {
      description: "Disables drag-and-drop for this item.",
      type: "boolean",
      default: "false",
    },
  }}
/>

---

For more advanced usage, see the source code and the [dnd-kit documentation](https://docs.dndkit.com/).
